# 숨바꼭질 4

Number: 13913
Tags: 1주차
Tier: Gold 4
URL: https://www.acmicpc.net/problem/13913
고른사람: Bob Jimmy

- Contents
    
    

---

# 1. 문제 소개

## 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

## 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

## 출력

첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다.

## 예제 입력 1

```
5 17

```

## 예제 출력 1

```
4
5 10 9 18 17

```

## 예제 입력 2

```
5 17

```

## 예제 출력 2

```
4
5 4 8 16 17

```

## 출처

- 문제를 만든 사람: [baekjoon](https://www.acmicpc.net/user/baekjoon)

## 비슷한 문제

- [1697번. 숨바꼭질](https://www.acmicpc.net/problem/1697)
- [12851번. 숨바꼭질 2](https://www.acmicpc.net/problem/12851)
- [13549번. 숨바꼭질 3](https://www.acmicpc.net/problem/13549)

## 알고리즘 분류

- [그래프 이론](https://www.acmicpc.net/problem/tag/7)
- [그래프 탐색](https://www.acmicpc.net/problem/tag/11)
- [너비 우선 탐색](https://www.acmicpc.net/problem/tag/126)

## 메모

---

# 2. 아이디어

## 2.1. BFS

> 수빈이의 현재 위치 **`X`**로부터 **3가지**의 위치**`(X-1, X+1, 2*x)`**로 **BFS 탐색**
> 

3가지 위치에 대해 큐에 넣으면서 **BFS 탐색**을 이어간다.

큐에서 뽑은 위치가 동생의 위치와 같은 경우를 찾는다. 그 때,

**depth** = 해당 위치에 도착한 시간

![Untitled](%E1%84%89%E1%85%AE%E1%86%B7%E1%84%87%E1%85%A1%E1%84%81%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%B5%2080c1d/Untitled.png)

## 2.2. DP

> Bottom-up 메모이제이션 기법
> 

**DP[i] = i위치에 도착하는데 걸리는 최소 시간**

**prev[i] = i위치에 최소한으로 도착할 때 이전 위치**

- i위치에 도달하는 경우의 수
    1. i-1 에서 오른쪽으로 한 칸
    2. i+1에서 왼쪽으로 한 칸
    3. i가 짝수일 때, i/2에서 점프

```java
// DP[i]부터 계산
DP[i] = MIN(DP[i-1],DP[i/2])+1 // i가 홀수일 때 DP[i/2]는 고려 안함
min_i = minLocation(i-1, i/2); // 위에서 i-1, i/2 둘 중 빨랐던 경우의 위치 저장
prev[i] = min_i; // 이전단계의 위치 저장

// DP[i]계산 후 DP[i-1]도 업데이트
DP[i-1] = MIN(DP[i-1],DP[i]+1) // i위치에서 i-1위치로 갈 때 기존의 dp[i-1]보다 빠를 경우
min_i = minLocation(i-1, i); // 위에서 i-1, i 둘 중 빨랐던 경우의 위치 저장
prev[i-1] = min_i; // 이전단계의 위치 저장
```

**Bottom-up 방식으로 DP[K] 값을 계산하면 된다**

경로 출력은 도착지부터 출발지까지 prev[i]를 거슬러 올라가 역순으로 출력하면 된다.

---

# 3. 다른 문제 풀이 노트

## 3.1. 성곽

### 3.1.1. 아이디어

![Untitled](%E1%84%89%E1%85%AE%E1%86%B7%E1%84%87%E1%85%A1%E1%84%81%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%B5%2080c1d/Untitled%201.png)

- 하위 0~3비트 : 벽 정보
- 4번 비트 : BFS시 visit 여부
- 5~ 번 비트 : 그래프의 컴포넌트 넘버(방 번호)

### 3.1.2. 풀이

<aside>
🔑 1차 : BFS탐색, 컴포넌트 넘버 구하기

</aside>

<aside>
🔑 2차 : 4방향에 대해 다른 컴포넌트가 있을 시 허물 경우 최대 방의 크기 계산

</aside>

## 3.2 가르침

### 3.2.2. 아이디어

![Untitled](%E1%84%89%E1%85%AE%E1%86%B7%E1%84%87%E1%85%A1%E1%84%81%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%B5%2080c1d/Untitled%202.png)

- 하위 0번~25번 비트 : a~z

```java
int lang // 가르친 알파벳의 flag
int[] word_bits // 각 단어별 사용한 알파벳 flag들
```

초기값으로 **lang**에는 **`a,c,i,n,t`**에 해당하는 **bit**가 **set**됨

어떤 단어 **word**가 “aaaabeed”라면, 이 단어의 **word_bit = 00 0000... 0001 1011**

<aside>
🔑 **내가 가르친 단어**로 **표현 가능한 단어**인지 확인하는 방법
**if** (~lang & word == 0) **then** **`readable`**

</aside>

모든 경우의 수로 가르칠 알파벳 **조합을 구해** **`lang`** bit를 **set**

구한 **`lang`**으로 표현 가능한 단어 수 계산, 최대값 갱신

```java
private static void selectAlphabet(int cnt,int start, int lang) {
	// 가르칠 알파벳을 고른 경우
	if (cnt >= K) {
		// 읽을 수 있는 단어수 계산
		int readable = 0;
		for (int i = 0; i < N; i++) {
			if ((~lang & word_bits[i]) == 0)
				readable++;
		}
		maxWord = Math.max(maxWord, readable);
		return;
	}
	for (int i = start; i < 26; i++) {
		// 쓰지 않는 알파벳이면 넘어감
		if ((usedAlphabet&1<<i) == 0)
			continue;
		// 이미 고른거는 넘어감
		if ((lang & 1 << i) != 0)
			continue;
		
		selectAlphabet(cnt + 1, i + 1, lang | 1 << i);
	}

}
```

## 3.3. 신입사원

### 3.3.1. 아이디어

1. 서류시험 순위로 **Priority Queue**에 담음
2. 앞에서부터 한 명씩 빼면서 **자격 확인**
3. 내 앞에서 검증한 사람은 **나보다 서류시험이 높음**, 그럼 나는 **앞 사람들보다 면접시험 순위가 높으면** **OK**

## 3.4. 전구와 스위치

### 3.4.1. 아이디어

<aside>
🔑 **`i`**번 전구를 **`i+1`**번 전구를 이용해서 **set**

</aside>

→ 0번부터 N-2번까지 쭈욱 설정해줌.

**그럼 마지막 전구`(N-1)`는 누가 설정해주지?**

<aside>
🔥 0번을 set할 때**, 0번을 직접 켰는지 1번을 이용했는지**에 따라 **`N-1`**(마지막)전구가 결정됨

</aside>

→ 0번은 1번으로 켜거나 끌 수도 있고, 0번 자체를 켜거나 끌 수도 있어서 그렇다.